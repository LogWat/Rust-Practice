# Chapter 3

**型** 
- `i : int`
- `u : unsigned`
- `f : float`

(`i`, `u`は8~128までサイズ指定可能. `f`は32 or 64のみ)

- その他に環境に依存したサイズの`isize`と`usize`が存在する
- 文字列型は`str`のみ (標準ライブラリで定義された`String`が使える)
- `str`は変更不可だが`String`は可能 (相互変換が可能)
- `impl`で構造体のメンバ関数を定義できる。自分の変数参照は`&self` (メンバ変数の書き換えが必要な時は`&mut self`にすること)


**頻出する標準ライブラリの型**<br>
`Option`, `Result`, `Vec`, `Box`
- `Option`型は戻り値がないかもしれないとき
- `Result`型は失敗するかもしれないとき
- `?`演算子 : `Ok()`なら値展開, `Err()`ならそのまま`return`
- `Vec`型はベクタ型 `push`と`pop`が使える(スタックみたい？)
- `Box`型はheap領域を動的に確保し、その領域へのポインタをスタックに保存する型 
---
**変数**
- Rustではデフォで変数の変更ができない。変更したい場合は`mut`
- `const`は途中変更不可の変数 任意の場所から参照可能
- `static`は変更可能にもできる ただし任意の場所から編集可能になるため注意が必要 (`lazy_static`という外部クレートが存在)
---
**基本的な制御構文**
- C++とかの `if ? then : else` みたいな構文が`if`でできる (ただし返り値は一致している必要アリ)
- ループは`loop`, `while`, `for`
- `loop`は値を返す繰り返し式 `while`, `for`は大方C++とかと同じ
- ~~Goみたいに`'`でラベル付けすることもできるらしいけどそれやってまたクソコードとか言われない？~~
- `match`はCとかの`switch`の強化版のようなもの 指定した要素の取りうる値を全て網羅するように`default`の処理(Rustの場合はアンダースコア_)を必ず設定する必要がある
- `Iterator`についてはInterator.rs参照
---
**関数**
- 基本的な書き方は`fn name(parameter) -> return value {}`
- `return`は書かなくていい 戻り値にはセミコロンがいらない. ただし, 途中で値を返したいときは`return`を明記してよい 
- `impl`で各構造体にメソッドを持たせることができる(その構造体独自の関数. メンバを表示したり)
- メソッドの戻り値に自分自身の型を指定すると(`fn a(&self) -> &Self {}`)メソッドチェーンができる。
---
**マクロ**
- `/libcore/macros/mod.rs`で定義されている
- `concat!` <= `strncat`みたいなもん
- `format!` <= 文字列連結系
- `panic!` <= プログラムの異常終了 (`exit(0)`?)
- `env!` <= 環境変数取得
- `cfg!` <= 該当フラグがコンパイラから渡されているかの判別
- `line!` <= `line!`マクロが呼び出された行番号の取得
- `file!` <= ファイル名取得用マクロ
- `unimplemented!`, `todo!`, `unreachable!`など未実装時のデバック用マクロも存在
- <span style="color: red">トレイトとは？</span> ぱっと見自分で定義した型( `struct`とか)を標準実装の別名として利用できる…ような感じ？(~~~いきなり出てきて雰囲気つかめって言われても…~~~)
---
**ゼロコスト抽象化**
- カプセル化：複雑な処理をするオブジェクトのデータと内部構造をあえて外部から見られないようにすることで、その機構を扱いやすくすること（？）
- ポリモーフィズム：同じような処理をする異なるオブジェクトをまとめ、使い方を共通化する（？）
- カプセル化＆ポリモーフィズム <= 抽象化は便利だが無駄な処理をはさむ => 実行時ではなくコンパイル時に抽象化されたコード表現を具体化することでなるべく実行時のコストを減らす（ゼロにする）
- `trait` : 様々な型に共通のメソッドを実装できるようにする
- `dyn` : トレイトオブジェクトへの動的ディスパッチをする
- ジェネリクス：どんな型でも同じ処理をさせるために使える
- 所有権：Rustではそれぞれの値には所有権が存在し，それを有するのはただ1つの所有者（変数）だけであるということ => スコープ外に出た変数の値破棄を可能にし，メモリの二重解放を防ぐ
- 借用：ある値の所有者に，その値の参照をする権利のみを与えてもらうこと
- ライフタイム：もし所有者によってある値が破壊されたとき，その値を参照している人がいた場合誤った参照をしてしまう．これを防ぐために，参照できる期間は「所有者よりも短ければならない」という明確な制限が必要であり，これをライフタイムという
- ムーブセマンティクス：右から左のオブジェクトに「所有権」が移ること（値が移るC++などはコピーセマンティクス）
---
**参照**
- 不可変の参照渡しはいくらでも可能だが，可変の参照渡しは１つだけ
- 元の所有者のライフタイムよりもながく参照することはできない
---
**RAII(Resource Acquisition Is Initialization)**
変数の初期化時にリソースを確保し，破棄するときには解放する．Rustの場合は変数がスコープから外れた時点でリソースの解放（ネットワークのコネクション破棄やファイル管理破棄など）する


---
**Thread Safe**
- Thread Safeとは：マルチスレッドで動作しても問題ないようにすること(メモリアクセスだったり)
- シングルスレッドで所有権を共有するために`Rc`という方が用意されている
- マルチスレッドでは`Arc`を利用する
- `Arc`では変数の書き換えができない（マルチスレッドめんどくさすぎるだろ…）
- メッセージパッシング：共有メモリ以外のスレッド間データ共有方法の一つ 各スレッドがメッセージをやり取りできるようなチャンネルを持っている
---
**非同期プログラミング**
- 複数のタスクを同時に実行できるのが非同期処理
- Apacheのようにリクエストごとに専用のスレッドを作成し，割当る並列処理方式と，nginxやNode.jsのような「必要なタイミングに，必要な処理を，空いているリソースに割り当てる」形で動作するイベント駆動モデルの実装が存在する
- `Future`：非同期タスクのこと このトレイトを実装した型を戻り値とすることで，非同期ランタイムにわたった時点で処理タイミングが制御される
- 非同期ランタイム（単にランタイムとも）：`Future`の実行タイミングを制御し，必要なタイミングで処理を走らせる
- `async`：「`Future`トレイトを実装した型を返す関数」を通常の関数と同じように記述できる構文
- `await`：`async`で実装された関数の処理結果を受け取る必要があるタイミングを記述する構文
- `async fn`は`impl Future`のシュガーシンタックス
- `async`構文はその都度`.await`しなければならない