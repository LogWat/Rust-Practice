# Chapter 3

**型** 
- `i : int`
- `u : unsigned`
- `f : float`

(`i`, `u`は8~128までサイズ指定可能. `f`は32 or 64のみ)

- その他に環境に依存したサイズの`isize`と`usize`が存在する
- 文字列型は`str`のみ (標準ライブラリで定義された`String`が使える)
- `str`は変更不可だが`String`は可能 (相互変換が可能)
- `impl`で構造体のメンバ関数を定義できる。自分の変数参照は`&self` (メンバ変数の書き換えが必要な時は`&mut self`にすること)


**頻出する標準ライブラリの型**<br>
`Option`, `Result`, `Vec`, `Box`
- `Option`型は戻り値がないかもしれないとき
- `Result`型は失敗するかもしれないとき
- `?`演算子 : `Ok()`なら値展開, `Err()`ならそのまま`return`
- `Vec`型はベクタ型 `push`と`pop`が使える(スタックみたい？)
- `Box`型はheap領域を動的に確保し、その領域へのポインタをスタックに保存する型 
---
**変数**
- Rustではデフォで変数の変更ができない。変更したい場合は`mut`
- `const`は途中変更不可の変数 任意の場所から参照可能
- `static`は変更可能にもできる ただし任意の場所から編集可能になるため注意が必要 (`lazy_static`という外部クレートが存在)
---
**基本的な制御構文**
- C++とかの `if ? then : else` みたいな構文が`if`でできる (ただし返り値は一致している必要アリ)
- ループは`loop`, `while`, `for`
- `loop`は値を返す繰り返し式 `while`, `for`は大方C++とかと同じ
- ~~Goみたいに`'`でラベル付けすることもできるらしいけどそれやってまたクソコードとか言われない？~~
- `match`はCとかの`switch`の強化版のようなもの 指定した要素の取りうる値を全て網羅するように`default`の処理(Rustの場合はアンダースコア_)を必ず設定する必要がある
- `Iterator`についてはInterator.rs参照
---
**関数**
- 基本的な書き方は`fn name(parameter) -> return value {}`
- `return`は書かなくていい 戻り値にはセミコロンがいらない. ただし, 途中で値を返したいときは`return`を明記してよい 
- `impl`で各構造体にメソッドを持たせることができる(その構造体独自の関数. メンバを表示したり)
- メソッドの戻り値に自分自身の型を指定すると(`fn a(&self) -> &Self {}`)メソッドチェーンができる。
---
**マクロ**
- `/libcore/macros/mod.rs`で定義されている
- `concat!` <= `strncat`みたいなもん
- `format!` <= 文字列連結系
- `panic!` <= プログラムの異常終了 (`exit(0)`?)
- `env!` <= 環境変数取得
- `cfg!` <= 該当フラグがコンパイラから渡されているかの判別
- `line!` <= `line!`マクロが呼び出された行番号の取得
- `file!` <= ファイル名取得用マクロ
- `unimplemented!`, `todo!`, `unreachable!`など未実装時のデバック用マクロも存在
- <span style="color: red">トレイトとは？</span> ぱっと見自分で定義した型( `struct`とか)を標準実装の別名として利用できる…ような感じ？(~~~いきなり出てきて雰囲気つかめって言われても…~~~)
---
**ゼロコスト抽象化**
- カプセル化：複雑な処理をするオブジェクトのデータと内部構造をあえて外部から見られないようにすることで、その機構を扱いやすくすること（？）
- ポリモーフィズム：同じような処理をする異なるオブジェクトをまとめ、使い方を共通化する（？）
- カプセル化＆ポリモーフィズム <= 抽象化は便利だが無駄な処理をはさむ => 実行時ではなくコンパイル時に抽象化されたコード表現を具体化することでなるべく実行時のコストを減らす（ゼロにする）
- `trait` : 様々な型に共通のメソッドを実装できるようにする
